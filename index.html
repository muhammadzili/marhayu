<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beranda - Marhayu</title>
    <link rel="shortcut icon" href="assets/marhayu-white.png" type="image/x-icon">
    <!-- 
        CATATAN OPTIMISASI: 
        Untuk penggunaan production, skrip Tailwind CDN ini sebaiknya diganti dengan file CSS yang sudah dicompile. 
        Proses 'build' akan menghapus semua class yang tidak terpakai, menghasilkan file yang jauh lebih kecil dan ringan.
        Lihat dokumentasi Tailwind CSS untuk info lebih lanjut.
    -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Lora:wght@400;700&family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <style>
        html, body { 
            overflow: hidden;
            height: 100%;
        }
        body { font-family: 'Inter', sans-serif; }
        .font-lora { font-family: 'Lora', serif; }
        .font-playfair { font-family: 'Playfair Display', serif; }
        .modal-content::-webkit-scrollbar, .sidebar-nav::-webkit-scrollbar, #poll-options-container::-webkit-scrollbar { display: none; }
        .modal-content, .sidebar-nav, #poll-options-container { -ms-overflow-style: none; scrollbar-width: none; }
        .icon-btn { transition: color 0.2s ease-in-out; }
        .preview-container { position: relative; }
        .remove-media-btn { position: absolute; top: 0.5rem; right: 0.5rem; background-color: rgba(0,0,0,0.6); border-radius: 9999px; width: 2rem; height: 2rem; color: white; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 1.5rem; line-height: 2rem; }
        .comment-pinned .bg-gray-100 { background-color: #f0f9ff !important; }
        .mention-popup { position: absolute; z-index: 100; background-color: white; border: 1px solid #e5e7eb; border-radius: 0.5rem; box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); max-height: 200px; overflow-y: auto; }
        .mention-item { display: flex; align-items: center; padding: 0.5rem; cursor: pointer; }
        .mention-item:hover { background-color: #f3f4f6; }
        .notification-badge { position: absolute; top: 0.5rem; right: 0.5rem; width: 0.75rem; height: 0.75rem; border-radius: 9999px; background-color: #ef4444; border: 2px solid white; }
        .custom-video-player { position: relative; background-color: #000; border-radius: 1rem; overflow: hidden; line-height: 0; }
        .custom-video-player video { display: block; margin: 0 auto; width: auto; height: auto; max-width: 100%; max-height: 560px; border-radius: 1rem; }
        .video-controls-overlay { position: absolute; inset: 0; background-color: rgba(0,0,0,0.2); display: flex; align-items: center; justify-content: center; opacity: 0; transition: opacity 0.2s ease; cursor: pointer; }
        .custom-video-player:hover .video-controls-overlay { opacity: 1; }
        .video-controls-overlay .play-pause-btn { background: rgba(0,0,0,0.5); border: 2px solid white; color: white; width: 4rem; height: 4rem; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 2rem; }
        .volume-btn { position: absolute; bottom: 0.75rem; right: 0.75rem; background: none; border: none; color: white; font-size: 1.5rem; cursor: pointer; text-shadow: 0 0 5px black; z-index: 10; }
        .video-progress-bar { position: absolute; bottom: 0; left: 0; width: 100%; height: 5px; background-color: rgba(255,255,255,0.3); cursor: pointer; }
        .video-progress-filled { width: 0%; height: 100%; background-color: #fff; }
        
        #global-reaction-popover {
            position: fixed; /* Changed to fixed */
            background-color: white;
            border-radius: 9999px;
            padding: 0.25rem 0.5rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            gap: 0.5rem;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transform: scale(0.9) translateY(10px);
            transition: opacity 0.15s ease-out, transform 0.15s ease-out, visibility 0s linear 0.2s;
        }
        #global-reaction-popover.visible {
            opacity: 1;
            visibility: visible;
            transform: scale(1) translateY(0);
            transition-delay: 0s;
        }
        .reaction-emoji { font-size: 1.5rem; cursor: pointer; transition: transform 0.15s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .reaction-emoji:hover { transform: scale(1.4); }
        .reaction-summary { display: flex; align-items: center; flex-wrap: wrap; gap: 0.5rem; margin-top: 0.75rem; }
        .reaction-pill { display: flex; align-items: center; gap: 0.25rem; background-color: #eef2ff; padding: 0.125rem 0.5rem; border-radius: 9999px; font-size: 0.75rem; font-weight: 500; }
        .user-reacted { background-color: #c7d2fe; border: 1px solid #818cf8; }

        #comment-modal, #confirm-modal, #poll-modal { transition: opacity 0.25s ease, visibility 0.25s ease; opacity: 0; visibility: hidden; }
        #comment-modal.is-visible, #confirm-modal.is-visible, #poll-modal.is-visible { opacity: 1; visibility: visible; }
        #comment-modal .modal-box, #confirm-modal .modal-box, #poll-modal .modal-box { transition: transform 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275); transform: scale(0.95) translateY(15px); }
        #comment-modal.is-visible .modal-box, #confirm-modal.is-visible .modal-box, #poll-modal.is-visible .modal-box { transform: scale(1) translateY(0); }

        .skeleton { background-color: #e5e7eb; border-radius: 0.5rem; animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        @keyframes pulse { 50% { opacity: .5; } }

        .interactive-btn { transition: transform 0.1s ease-out, background-color 0.2s ease; }
        .interactive-btn:active { transform: scale(0.95); }
        .post-enter-animation { animation: fadeInSlideUp 0.5s ease-out forwards; opacity: 0; }
        @keyframes fadeInSlideUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        /* --- Poll Styles Updated --- */
        .poll-option {
            position: relative;
            border: 1px solid #d1d5db;
            border-radius: 0.75rem;
            padding: 0.75rem;
            cursor: pointer;
            overflow: hidden;
            transition: border-color 0.2s, background-color 0.2s;
        }
        .poll-option:hover { border-color: #6366f1; }
        .poll-option.user-voted { 
            border-color: #4f46e5; 
            background-color: #e0e7ff; 
            font-weight: 500;
        }
        .poll-progress {
            position: absolute;
            top: 0; left: 0; height: 100%;
            background-color: #c7d2fe;
            width: 0%;
            z-index: 1;
            /* Added transition for smooth animation */
            transition: width 0.5s cubic-bezier(0.22, 1, 0.36, 1);
        }
        .poll-option-content { position: relative; z-index: 2; display: flex; justify-content: space-between; align-items: center; }
        .poll-option-percent { font-weight: 600; }
        .copied-post-label {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.125rem 0.5rem;
            background-color: #f3f4f6;
            border-radius: 9999px;
            font-size: 0.75rem;
            color: #4b5563;
            margin-top: 0.5rem;
        }
        
        /* Toast Notification */
        #toast-notification {
            position: fixed;
            bottom: 5rem;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background-color: rgba(17, 24, 39, 0.8);
            backdrop-filter: blur(4px);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: transform 0.3s ease, opacity 0.3s ease, visibility 0s linear 0.3s;
        }
        #toast-notification.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
            visibility: visible;
            transition-delay: 0s;
        }

    </style>
</head>
<body class="bg-white text-black">

    <div class="container mx-auto max-w-4xl flex flex-row md:gap-8 h-full">
        <!-- Sidebar and Main content are the same -->
        <aside class="hidden md:block w-[280px] flex-shrink-0 pt-8 pr-4">
            <a href="index.html"><img src="https://mage.mzili.my.id/uploads/img_68c50e457ef002.30239660.png" alt="Logo Marhayu" class="h-10 mb-8"></a>
            <nav class="space-y-1 text-lg sidebar-nav">
                <a href="index.html" class="flex items-center space-x-3 p-3 rounded-full hover:bg-gray-100 transition-colors font-bold text-black"><i class="bi bi-house-door-fill text-2xl"></i><span>Beranda</span></a>
                <a href="search.html" class="flex items-center space-x-3 p-3 rounded-full hover:bg-gray-100 transition-colors"><i class="bi bi-search text-2xl"></i><span>Pencarian</span></a>
                 <a href="notifications.html" class="relative flex items-center space-x-3 p-3 rounded-full hover:bg-gray-100 transition-colors">
                    <i class="bi bi-bell text-2xl"></i><span>Notifikasi</span>
                    <span id="notification-badge-sidebar" class="hidden notification-badge"></span>
                </a>
                <a href="#" id="profile-link-sidebar" class="flex items-center space-x-3 p-3 rounded-full hover:bg-gray-100 transition-colors"><i class="bi bi-person text-2xl"></i><span>Profil</span></a>
            </nav>
            <button id="logout-button" class="mt-8 w-full bg-black text-white py-2 rounded-full font-semibold hover:bg-gray-800 transition-colors interactive-btn">Keluar</button>
        </aside>

        <main class="w-full min-w-0 md:border-l md:border-r border-gray-200 h-full overflow-y-auto">
            <header class="sticky top-0 z-10 bg-white/80 backdrop-blur-sm border-b border-gray-200 px-4 py-3">
                 <h1 class="text-xl font-bold md:hidden"><img src="https://mage.mzili.my.id/uploads/img_68c50e457ef002.30239660.png" alt="Logo Marhayu" class="h-8 mx-auto"></h1>
                <h1 id="main-header-title" class="text-xl font-bold hidden md:block">Beranda</h1>
            </header>

            <div class="p-4 border-b border-gray-200 relative">
                <textarea id="post-content" class="w-full p-2 text-lg border-none focus:ring-0 resize-none transition-all duration-300" rows="3" placeholder="Apa yang sedang terjadi?"></textarea>
                <div id="post-mention-popup" class="mention-popup hidden"></div>
                <div id="media-preview-container" class="mt-2"></div>
                
                <div class="flex items-center justify-between mt-2">
                     <div class="flex items-center space-x-4 text-xl text-gray-500">
                        <label for="image-upload" class="cursor-pointer hover:text-blue-500"><i class="bi bi-image"></i></label>
                        <input type="file" id="image-upload" class="hidden" accept="image/*">
                        <label for="video-upload" class="cursor-pointer hover:text-green-500"><i class="bi bi-camera-video"></i></label>
                        <input type="file" id="video-upload" class="hidden" accept="video/*">
                        <button id="poll-button" class="cursor-pointer hover:text-orange-500"><i class="bi bi-bar-chart-line"></i></button>
                        <button id="full-text-style-button" class="cursor-pointer hover:text-purple-500"><i class="bi bi-fonts"></i></button>
                    </div>
                     <button id="submit-post" class="bg-black text-white px-6 py-2 rounded-full font-semibold hover:bg-gray-800 transition-colors disabled:opacity-50 interactive-btn" disabled>Posting</button>
                </div>
            </div>

            <div id="timeline"><p class="p-4 text-center text-gray-500">Memuat postingan...</p></div>
        </main>
    </div>
    
    <!-- Bottom Nav is the same -->
    <nav id="bottom-nav" class="md:hidden fixed bottom-0 w-full bg-white border-t border-black/10 z-20">
        <div class="flex justify-around items-center h-16">
            <a href="index.html" class="flex flex-col items-center justify-center text-gray-500 hover:text-black">
                <i class="bi bi-house-door text-2xl"></i>
            </a>
            <a href="search.html" class="flex flex-col items-center justify-center text-gray-500 hover:text-black">
                <i class="bi bi-search text-2xl"></i>
            </a>
            <a href="notifications.html" class="relative flex flex-col items-center justify-center text-gray-500 hover:text-black">
                <i class="bi bi-bell text-2xl"></i>
                <span id="notification-badge-bottom" class="hidden notification-badge"></span>
            </a>
            <a href="#" id="profile-link-bottom" class="flex flex-col items-center justify-center text-gray-500 hover:text-black">
                <i class="bi bi-person text-2xl"></i>
            </a>
        </div>
    </nav>

    <!-- Comment Modal is the same -->
    <div id="comment-modal" class="fixed inset-0 bg-black bg-opacity-30 items-center justify-center hidden z-50">
        <div class="bg-white rounded-2xl w-full max-w-lg mx-4 border border-black/20 overflow-hidden flex flex-col max-h-[90vh] modal-box">
            <div class="flex justify-between items-center p-4 border-b border-black/10">
                <h2 class="font-bold text-lg">Postingan</h2>
                <button id="close-modal-button" class="text-2xl hover:text-gray-500 transition-colors">&times;</button>
            </div>
            <div id="modal-content" class="p-4 overflow-y-auto modal-content"></div>
             <div class="p-4 border-t border-black/10 mt-auto relative">
                 <div id="replying-to-banner" class="hidden text-sm text-gray-500 mb-2"></div>
                <div class="flex space-x-2">
                    <input type="text" id="comment-input" placeholder="Tulis komentar..." class="w-full px-4 py-2 border border-black/20 rounded-lg focus:outline-none focus:ring-1 focus:ring-black">
                    <button id="submit-comment" class="bg-black text-white px-4 py-2 rounded-lg font-semibold hover:bg-gray-800 interactive-btn">Kirim</button>
                </div>
                 <div id="comment-mention-popup" class="mention-popup hidden"></div>
            </div>
        </div>
    </div>
    
    <!-- Full Text Modal is the same -->
    <div id="full-text-modal" class="fixed inset-0 bg-black bg-opacity-30 items-center justify-center hidden z-50">
        <div class="bg-white rounded-2xl w-full max-w-sm mx-4 border border-black/20 overflow-hidden">
            <div class="flex justify-between items-center p-4 border-b border-black/10">
                <h2 class="font-bold text-lg">Gaya Teks Penuh</h2>
                <button id="close-full-text-modal" class="text-2xl hover:text-gray-500 transition-colors">&times;</button>
            </div>
            <div class="p-4 space-y-4">
                <div>
                    <h3 class="font-semibold mb-2">Warna Latar</h3>
                    <div class="grid grid-cols-5 gap-2" id="color-swatches">
                        <button class="w-10 h-10 rounded-full bg-gradient-to-br from-red-500 to-orange-500" data-color="bg-gradient-to-br from-red-500 to-orange-500"></button>
                        <button class="w-10 h-10 rounded-full bg-gradient-to-br from-blue-500 to-teal-500" data-color="bg-gradient-to-br from-blue-500 to-teal-500"></button>
                        <button class="w-10 h-10 rounded-full bg-gradient-to-br from-purple-600 to-indigo-600" data-color="bg-gradient-to-br from-purple-600 to-indigo-600"></button>
                        <button class="w-10 h-10 rounded-full bg-gradient-to-br from-pink-500 to-rose-500" data-color="bg-gradient-to-br from-pink-500 to-rose-500"></button>
                        <button class="w-10 h-10 rounded-full bg-gray-800" data-color="bg-gray-800"></button>
                    </div>
                </div>
                <div>
                    <h3 class="font-semibold mb-2">Gaya Huruf</h3>
                    <div class="grid grid-cols-3 gap-2" id="font-swatches">
                        <button class="p-2 border rounded-lg font-inter" data-font="font-inter">Netral</button>
                        <button class="p-2 border rounded-lg font-lora" data-font="font-lora">Elegan</button>
                        <button class="p-2 border rounded-lg font-playfair" data-font="font-playfair">Klasik</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Confirmation Modal is the same -->
    <div id="confirm-modal" class="fixed inset-0 bg-black bg-opacity-40 items-center justify-center hidden z-[60]">
        <div class="bg-white rounded-2xl w-full max-w-sm mx-4 border border-black/10 overflow-hidden modal-box text-center p-6">
            <div class="text-5xl text-red-500 mb-4"><i class="bi bi-exclamation-triangle"></i></div>
            <h2 id="confirm-modal-title" class="font-bold text-lg mb-2">Konfirmasi Aksi</h2>
            <p id="confirm-modal-message" class="text-gray-600 mb-6">Apakah Anda yakin ingin melanjutkan?</p>
            <div class="flex justify-center gap-4">
                <button id="confirm-modal-cancel" class="w-full px-4 py-2 bg-gray-200 text-gray-800 rounded-lg font-semibold hover:bg-gray-300 interactive-btn">Batal</button>
                <button id="confirm-modal-confirm" class="w-full px-4 py-2 bg-red-600 text-white rounded-lg font-semibold hover:bg-red-700 interactive-btn">Hapus</button>
            </div>
        </div>
    </div>
    
    <!-- Poll Creation Modal is the same -->
    <div id="poll-modal" class="fixed inset-0 bg-black bg-opacity-30 items-center justify-center hidden z-50">
        <div class="bg-white rounded-2xl w-full max-w-lg mx-4 border border-black/20 overflow-hidden flex flex-col max-h-[90vh] modal-box">
            <div class="flex justify-between items-center p-4 border-b border-black/10">
                <h2 class="font-bold text-lg">Buat Polling</h2>
                <button id="close-poll-modal" class="text-2xl hover:text-gray-500 transition-colors">&times;</button>
            </div>
            <div class="p-4 space-y-4">
                <textarea id="poll-question" class="w-full p-2 text-lg border rounded-md focus:ring-1 focus:ring-black resize-none" rows="2" placeholder="Pertanyaan polling..."></textarea>
                <div id="poll-options-container" class="space-y-2 max-h-60 overflow-y-auto">
                    <!-- Poll options will be added here -->
                </div>
                <button id="add-poll-option" class="text-sm text-blue-600 hover:underline font-semibold">+ Tambah Opsi</button>
            </div>
            <div class="p-4 border-t border-black/10 mt-auto text-right">
                <button id="submit-poll-post" class="bg-black text-white px-6 py-2 rounded-full font-semibold hover:bg-gray-800 transition-colors disabled:opacity-50 interactive-btn" disabled>Posting Polling</button>
            </div>
        </div>
    </div>

    <!-- Toast Notification is the same -->
    <div id="toast-notification">Tautan telah disalin!</div>
    
    <!-- Global Reaction Popover -->
    <div id="global-reaction-popover">
        <!-- Emoji content will be populated by JS -->
    </div>


    <script>
        const { createClient } = supabase;
        const SUPABASE_URL = 'https://ibqyhadodgcneqqbbfyg.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlicXloYWRvZGdjbmVxcWJiZnlnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc3NDQyNTUsImV4cCI6MjA3MzMyMDI1NX0.hrxUV6MPXH9Yiq-7-NOXw0s-p38sC5blpSY3iBc439w';
        const db = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        let currentUser = null, currentUserProfile = null, postImageFile = null, postVideoFile = null, activePostForComment = null, isFullTextMode = false, fullTextColor = '', fullTextFont = '', activeReplyTo = null;
        let commentsById = new Map();
        let confirmCallbackHolder = () => {};
        let followingIds = [];
        let recentlyUpdatedPostLikes = new Set();
        let recentlyUpdatedCommentLikes = new Set();
        let reactionPopoverTimeout; // To manage showing/hiding popover
        
        const timeline = document.getElementById('timeline');
        const postContentInput = document.getElementById('post-content');
        const submitPostButton = document.getElementById('submit-post');
        const imageUploadInput = document.getElementById('image-upload');
        const videoUploadInput = document.getElementById('video-upload');
        const mediaPreviewContainer = document.getElementById('media-preview-container');
        const commentModal = document.getElementById('comment-modal'), closeModalButton = document.getElementById('close-modal-button'), modalContent = document.getElementById('modal-content'), commentInput = document.getElementById('comment-input'), submitCommentButton = document.getElementById('submit-comment'), replyingToBanner = document.getElementById('replying-to-banner');
        const fullTextStyleButton = document.getElementById('full-text-style-button'), fullTextModal = document.getElementById('full-text-modal'), closeFullTextModalButton = document.getElementById('close-full-text-modal'), colorSwatches = document.getElementById('color-swatches'), fontSwatches = document.getElementById('font-swatches');
        
        const pollButton = document.getElementById('poll-button');
        const pollModal = document.getElementById('poll-modal');
        const closePollModalButton = document.getElementById('close-poll-modal');
        const pollQuestionInput = document.getElementById('poll-question');
        const pollOptionsContainer = document.getElementById('poll-options-container');
        const addPollOptionButton = document.getElementById('add-poll-option');
        const submitPollPostButton = document.getElementById('submit-poll-post');
        const globalReactionPopover = document.getElementById('global-reaction-popover');
        
        // --- START FIX: Populate the global reaction popover with emojis ---
        const availableReactions = ['ðŸ‘', 'â¤ï¸', 'ðŸ˜‚', 'ðŸ˜®', 'ðŸ˜¢'];
        globalReactionPopover.innerHTML = availableReactions
            .map(emoji => `<span class="reaction-emoji" data-reaction="${emoji}">${emoji}</span>`)
            .join('');
        // --- END FIX ---


        function createSkeletonPostElement() {
            const div = document.createElement('div');
            div.className = 'p-4 border-b border-gray-200 flex space-x-4';
            div.innerHTML = `
                <div class="w-12 h-12 rounded-full skeleton flex-shrink-0"></div>
                <div class="w-full space-y-3">
                    <div class="flex justify-between items-center">
                        <div class="w-1/2 h-5 skeleton"></div>
                    </div>
                    <div class="w-full h-4 skeleton"></div>
                    <div class="w-3/4 h-4 skeleton"></div>
                    <div class="w-full h-48 skeleton mt-2 !rounded-xl"></div>
                </div>
            `;
            return div;
        }

        // --- START FIX: Create a better skeleton loader for the comment modal ---
        function createCommentSkeletonLoader() {
            return `
                <div class="p-4 animate-pulse">
                    <div class="flex space-x-4">
                        <div class="w-12 h-12 rounded-full bg-gray-200 flex-shrink-0"></div>
                        <div class="w-full space-y-3">
                            <div class="w-1/2 h-5 bg-gray-200 rounded"></div>
                            <div class="w-full h-4 bg-gray-200 rounded"></div>
                            <div class="w-3/4 h-4 bg-gray-200 rounded"></div>
                        </div>
                    </div>
                    <hr class="my-4 border-gray-200">
                    <div class="flex space-x-3 mt-4">
                        <div class="w-10 h-10 rounded-full bg-gray-200 flex-shrink-0"></div>
                        <div class="flex-1 space-y-2">
                            <div class="w-1/3 h-4 bg-gray-200 rounded"></div>
                            <div class="w-full h-8 bg-gray-200 rounded-xl"></div>
                        </div>
                    </div>
                    <div class="flex space-x-3 mt-4">
                        <div class="w-10 h-10 rounded-full bg-gray-200 flex-shrink-0"></div>
                        <div class="flex-1 space-y-2">
                            <div class="w-1/4 h-4 bg-gray-200 rounded"></div>
                            <div class="w-full h-12 bg-gray-200 rounded-xl"></div>
                        </div>
                    </div>
                </div>
            `;
        }
        // --- END FIX ---

        function showConfirmModal(message, onConfirm, { title = 'Konfirmasi Hapus', confirmText = 'Hapus', cancelText = 'Batal' } = {}) {
            const confirmModal = document.getElementById('confirm-modal');
            document.getElementById('confirm-modal-title').textContent = title;
            document.getElementById('confirm-modal-message').textContent = message;
            document.getElementById('confirm-modal-confirm').textContent = confirmText;
            document.getElementById('confirm-modal-cancel').textContent = cancelText;

            confirmCallbackHolder = onConfirm;

            confirmModal.classList.remove('hidden');
            confirmModal.classList.add('flex');
            setTimeout(() => confirmModal.classList.add('is-visible'), 10);
        }

        function hideConfirmModal() {
            const confirmModal = document.getElementById('confirm-modal');
            confirmModal.classList.remove('is-visible');
            setTimeout(() => {
                confirmModal.classList.add('hidden');
                confirmModal.classList.remove('flex');
            }, 250);
        }

        function setupModalListeners() {
            const confirmModal = document.getElementById('confirm-modal');
            const confirmBtn = document.getElementById('confirm-modal-confirm');
            const cancelBtn = document.getElementById('confirm-modal-cancel');

            confirmBtn.addEventListener('click', () => {
                if (typeof confirmCallbackHolder === 'function') {
                    confirmCallbackHolder();
                }
                hideConfirmModal();
            });

            cancelBtn.addEventListener('click', hideConfirmModal);
            confirmModal.addEventListener('click', (e) => {
                if (e.target === confirmModal) {
                    hideConfirmModal();
                }
            });
        }


        function setupVideoAutoplay() {
            const videos = document.querySelectorAll('#timeline video, #modal-content video');
            if (window.videoObserver) {
                window.videoObserver.disconnect();
            }
            if ('IntersectionObserver' in window) {
                const observerOptions = {
                    root: null,
                    rootMargin: '0px',
                    threshold: 0.8
                };
                const handleVideo = (entries, observer) => {
                    entries.forEach(entry => {
                        const video = entry.target;
                        if (entry.isIntersecting) {
                            video.play().catch(e => {});
                        } else {
                            video.pause();
                        }
                    });
                };
                window.videoObserver = new IntersectionObserver(handleVideo, observerOptions);
                videos.forEach(video => window.videoObserver.observe(video));
            } else {
                console.log("IntersectionObserver not supported, video autoplay on scroll disabled.");
            }
        }

        function highlightActiveNav() {
            const bottomNav = document.getElementById('bottom-nav');
            if (!bottomNav) return;
            const links = bottomNav.querySelectorAll('a');
            const currentPage = window.location.pathname.split('/').pop() || 'index.html';
            links.forEach(link => {
                const linkPage = link.getAttribute('href').split('/').pop();
                const icon = link.querySelector('i');
                if (linkPage === currentPage) {
                    link.classList.remove('text-gray-500');
                    link.classList.add('text-black');
                    if (icon.classList.contains('bi-house-door')) {
                        icon.className = 'bi bi-house-door-fill text-2xl';
                    } else if (icon.classList.contains('bi-search')) {
                        icon.className = 'bi bi-search-heart-fill text-2xl';
                    } else if (icon.classList.contains('bi-bell')) {
                        icon.className = 'bi bi-bell-fill text-2xl';
                    } else if (icon.classList.contains('bi-person')) {
                        icon.className = 'bi bi-person-fill text-2xl';
                    }
                }
            });
        }
        
        function showToast(message) {
            const toast = document.getElementById('toast-notification');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        async function initialize() { 
            const { data: { session } } = await db.auth.getSession();
            if (!session) {
                window.location.href = 'auth.html';
                return;
            }
            currentUser = session.user;
            document.getElementById('profile-link-sidebar').href = `profile.html?user_id=${currentUser.id}`;
            document.getElementById('profile-link-bottom').href = `profile.html?user_id=${currentUser.id}`;
            let { data: profile, error: profileError } = await db.from('profiles').select('*').eq('id', currentUser.id).maybeSingle();
             if (profileError || !profile) {
                console.error("Gagal memuat atau membuat profil:", profileError);
                timeline.innerHTML = `<div class="p-4 text-center text-red-500"><h2 class="font-bold text-lg">Kesalahan Kritis</h2><p>Tidak dapat memuat data profil. Ini mungkin karena masalah RLS atau API Key. Silakan periksa konsol untuk detail.</p></div>`;
                return;
            }
            currentUserProfile = profile;
            
            const urlParams = new URLSearchParams(window.location.search);
            const hashtagFromUrl = urlParams.get('hashtag');
            const headerTitle = document.getElementById('main-header-title');

            if (hashtagFromUrl) {
                headerTitle.textContent = `#${hashtagFromUrl}`;
            } else {
                headerTitle.textContent = 'Beranda';
            }
            
            const { data: followsData } = await db.from('follows').select('following_id').eq('follower_id', currentUser.id).eq('status', 'accepted');
            if (followsData) {
                followingIds = followsData.map(f => f.following_id);
            }

            await fetchPosts();
            setupModalListeners();
            subscribeToChanges();
            subscribeToNotifications();
            highlightActiveNav();

            const postIdFromUrl = urlParams.get('post_id');
            if (postIdFromUrl) openCommentModal(postIdFromUrl);
        }

        async function fetchPosts() {
            timeline.innerHTML = '';
            for (let i = 0; i < 3; i++) {
                timeline.appendChild(createSkeletonPostElement());
            }

            const urlParams = new URLSearchParams(window.location.search);
            const hashtagFromUrl = urlParams.get('hashtag');
            
            let query = db.from('posts').select(`*, profiles(*), likes(user_id), reactions(*), comments(count), poll_votes(user_id, option_text)`);

            if (hashtagFromUrl) {
                query = query.contains('hashtags', `{${hashtagFromUrl.toLowerCase()}}`);
            }
            
            query = query.order('last_copied_at', { ascending: false, nullsLast: true }).order('created_at', { ascending: false });

            const { data: posts, error } = await query;
            timeline.innerHTML = '';

            if (error) {
                console.error('Error fetching posts:', error.message || error);
                timeline.innerHTML = `<p class="p-4 text-center text-red-500">Gagal memuat postingan. Coba lagi nanti.</p>`;
                return;
            }
            
            const filteredPosts = posts.filter(post => {
                const author = post.profiles;
                if (!author) return false;
                if (author.id === currentUser.id) return true;
                if (!author.is_private) return true;
                if (author.is_private && followingIds.includes(author.id)) return true;
                return false;
            });

            if (filteredPosts.length === 0) {
                timeline.innerHTML = `<p class="p-4 text-center text-gray-500">Tidak ada postingan untuk ditampilkan.</p>`;
            } else {
                // --- START FIX: Render all posts at once to prevent glitches ---
                const postElements = filteredPosts.map((post, index) => {
                    const postElement = createPostElement(post);
                    postElement.style.animationDelay = `${index * 100}ms`;
                    return postElement;
                });
                timeline.append(...postElements);
                // --- END FIX ---
            }
            setupVideoAutoplay();
        }
        
        function subscribeToChanges() {
            db.channel('public-changes')
              .on('postgres_changes', { event: '*', schema: 'public', table: 'likes' }, (payload) => handleLikeChange(payload.new?.post_id || payload.old?.post_id))
              .on('postgres_changes', { event: '*', schema: 'public', table: 'reactions' }, (payload) => {
                  const postId = payload.new?.post_id || payload.old?.post_id;
                  updatePostReactionsUI(postId);
                  if (activePostForComment?.id == postId) {
                      updatePostReactionsUI(postId, modalContent);
                  }
              })
              .on('postgres_changes', { event: '*', schema: 'public', table: 'comments' }, (payload) => {
                  if (payload.eventType === 'INSERT') {
                      handleCommentInsert(payload.new);
                  } else if (payload.eventType === 'UPDATE') {
                      handleCommentLikeChange(payload.new.id);
                  }
              })
              .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'posts' }, async (payload) => {
                    const postId = payload.new.id;
                    console.log(`[Realtime] Received UPDATE for post [${postId}].`);

                    const postElement = document.getElementById(`post-${postId}`);
                    const modalPostElement = document.querySelector(`#modal-content #post-${postId}`);

                    if (payload.new.is_poll && (postElement || modalPostElement)) {
                        console.log(`[Realtime] Post is a poll and is visible. Refetching full poll data...`);
                        
                        const { data: updatedPost, error } = await db
                            .from('posts')
                            .select('poll_options, poll_votes(user_id, option_text)')
                            .eq('id', postId)
                            .single();

                        if (error) {
                            console.error(`[Realtime] Failed to refetch post data for poll update:`, error);
                            return;
                        }

                        console.log(`[Realtime] Refetch successful. Calling updatePollUI with fresh data:`, updatedPost);
                        
                        if (postElement) {
                            updatePollUI(postId, updatedPost.poll_options, updatedPost.poll_votes);
                        }
                        if (modalPostElement) {
                            updatePollUI(postId, updatedPost.poll_options, updatedPost.poll_votes, modalContent);
                        }
                    }
              })
              .subscribe();
        }

        async function subscribeToNotifications() {
            const updateBadge = async () => {
                const { count } = await db.from('notifications').select('*', { count: 'exact', head: true }).eq('recipient_id', currentUser.id).eq('is_read', false);
                const badges = [document.getElementById('notification-badge-sidebar'), document.getElementById('notification-badge-bottom')];
                badges.forEach(badge => {
                    if (!badge) return;
                    if (count > 0) {
                        badge.classList.remove('hidden');
                    } else {
                        badge.classList.add('hidden');
                    }
                });
            };
            await updateBadge();
            db.channel('public:notifications')
              .on('postgres_changes', { event: '*', schema: 'public', table: 'notifications', filter: `recipient_id=eq.${currentUser.id}` }, updateBadge)
              .subscribe();
        }
        
        async function handleLikeChange(postId, elementContext = null) {
            if (recentlyUpdatedPostLikes.has(postId)) return;

            const postElement = elementContext || document.getElementById(`post-${postId}`);
            if (!postElement) return;
            const likeButton = postElement.querySelector('.like-button:not(.like-comment-button)');
            if (!likeButton) return;
            const { data, error } = await db.from('posts').select(`likes(user_id)`).eq('id', postId).single();
            if (error) return console.error('Error fetching updated likes:', error.message || error);
            const likeCountSpan = likeButton.querySelector('.like-count');
            const icon = likeButton.querySelector('i');
            const likes = data.likes || [];
            const likeCount = likes.length;
            const userHasLiked = likes.some(like => like.user_id === currentUser.id);
            likeCountSpan.textContent = likeCount;
            likeButton.dataset.liked = userHasLiked;
            likeButton.classList.toggle('text-red-500', userHasLiked);
            icon.classList.toggle('bi-heart-fill', userHasLiked);
            icon.classList.toggle('bi-heart', !userHasLiked);
        }

        async function handleCommentLikeChange(commentId) {
            if (recentlyUpdatedCommentLikes.has(commentId)) return;

            const commentElement = document.getElementById(`comment-${commentId}`);
            if (!commentElement) return;

            const { data: comment, error } = await db.from('comments').select('liked_by').eq('id', commentId).single();
            if (error) {
                console.error("Error fetching comment update:", error);
                return;
            }

            const likeButton = commentElement.querySelector('.like-comment-button');
            if (!likeButton) return;

            const liked_by = comment.liked_by || [];
            const userHasLiked = liked_by.includes(currentUser.id);
            const likeCount = liked_by.length;

            likeButton.dataset.liked = userHasLiked;
            likeButton.querySelector('.comment-like-count').textContent = likeCount;
            const icon = likeButton.querySelector('i');
            likeButton.classList.toggle('text-red-500', userHasLiked);
            icon.classList.toggle('bi-heart-fill', userHasLiked);
            icon.classList.toggle('bi-heart', !userHasLiked);
        }

        function handleCommentInsert(newComment) {
            const postElement = document.getElementById(`post-${newComment.post_id}`);
            if(postElement) {
                const countSpan = postElement.querySelector('.comment-count');
                countSpan.textContent = parseInt(countSpan.textContent) + 1;
            }
            if (commentModal.classList.contains('is-visible') && activePostForComment && newComment.post_id === activePostForComment.id) {
                openCommentModal(activePostForComment.id);
            }
        }
        
        function createPostElement(post) { 
            const div = document.createElement('div');
            div.className = 'p-4 border-b border-gray-200 flex space-x-4 post-enter-animation';
            div.id = `post-${post.id}`;
            const profile = post.profiles;
            if (!profile) return div;
            const userHasLiked = (post.likes || []).some(like => like.user_id === currentUser.id);
            const likeCount = (post.likes || []).length;
            const commentCount = post.comments && post.comments[0] ? post.comments[0].count : 0;
            const userInitial = profile.full_name ? profile.full_name.charAt(0).toUpperCase() : '?';
            const profilePicUrl = profile.profile_avatar_url || `https://placehold.co/48x48/1A1A1A/FFFFFF?text=${userInitial}&font=inter`;
            
            const processedContent = post.content.replace(/@(\w+)|#(\w+)/g, (match, mention, hashtag) => {
                if (mention) {
                    return `<a href="profile.html?user_id=${profile.id}" class="text-blue-500 hover:underline">@${mention}</a>`;
                }
                if (hashtag) {
                    return `<a href="?hashtag=${hashtag.toLowerCase()}" class="text-blue-500 hover:underline">#${hashtag}</a>`;
                }
            });

            let copiedLabelHtml = '';
            if (post.last_copied_at) {
                 const copiedDate = new Date(post.last_copied_at);
                 const createdDate = new Date(post.created_at);
                 if (Date.now() - copiedDate.getTime() < 24 * 60 * 60 * 1000 && Math.abs(copiedDate.getTime() - createdDate.getTime()) > 1000) {
                    copiedLabelHtml = `<div class="copied-post-label"><i class="bi bi-link-45deg"></i> Baru saja dibagikan</div>`;
                 }
            }
            
            let postContentHtml = '';
            if (post.is_poll) {
                const pollVotes = post.poll_votes || [];
                const userVote = pollVotes.find(v => v.user_id === currentUser.id);
                const totalVotes = post.poll_options.reduce((sum, opt) => sum + opt.votes, 0);

                const optionsHtml = post.poll_options.map(option => {
                    const percent = totalVotes > 0 ? Math.round((option.votes / totalVotes) * 100) : 0;
                    const hasVotedThis = userVote && userVote.option_text === option.option;
                    const showResults = !!userVote;

                    return `
                        <div class="poll-option ${hasVotedThis ? 'user-voted' : ''}" data-option="${option.option}" data-post-id="${post.id}">
                            ${showResults ? `<div class="poll-progress" style="width: ${percent}%;"></div>` : ''}
                            <div class="poll-option-content">
                                <span>${option.option}</span>
                                ${showResults ? `<span class="poll-option-percent">${percent}%</span>` : ''}
                            </div>
                        </div>
                    `;
                }).join('');

                postContentHtml = `
                    <p class="my-2 whitespace-pre-wrap">${processedContent}</p>
                    <div class="mt-3 space-y-2 poll-container" id="poll-${post.id}">
                        <p class="font-bold text-lg">${post.poll_question}</p>
                        ${optionsHtml}
                        <p class="text-xs text-gray-500 text-right">${totalVotes} suara</p>
                    </div>
                `;
            } else if (post.is_full_text) {
                postContentHtml = `<div class="my-2 p-8 rounded-2xl flex items-center justify-center text-center text-white ${post.bg_color} min-h-[12rem]"><p class="text-2xl ${post.font_family}">${processedContent}</p></div>`;
            } else {
                let mediaHtml = '';
                if (post.image_url) {
                    mediaHtml = `<img src="${post.image_url}" loading="lazy" class="mt-2 rounded-2xl border border-black/10 w-full object-cover">`;
                } else if (post.video_url) {
                    mediaHtml = `<div class="mt-2 custom-video-player" data-post-id="${post.id}">
                                    <video src="${post.video_url}" preload="metadata" class="w-full h-full" loop muted playsinline onerror="this.closest('.custom-video-player').innerHTML = '<div class=\\'text-center p-8 bg-gray-100 rounded-2xl text-gray-500 flex items-center justify-center min-h-[200px]\\'>Gagal memuat video.</div>'"></video>
                                    <div class="video-controls-overlay">
                                        <button class="play-pause-btn interactive-btn"><i class="bi bi-play-fill text-3xl"></i></button>
                                        <button class="volume-btn"><i class="bi bi-volume-mute-fill"></i></button>
                                    </div>
                                    <div class="video-progress-bar"><div class="video-progress-filled"></div></div>
                                </div>`;
                }
                postContentHtml = `<p class="my-2 whitespace-pre-wrap">${processedContent}</p>${mediaHtml}`;
            }
            const reactions = post.reactions || [];
            const reactionCounts = reactions.reduce((acc, reaction) => {
                acc[reaction.reaction_type] = (acc[reaction.reaction_type] || 0) + 1;
                return acc;
            }, {});
            const sortedReactions = Object.entries(reactionCounts).sort((a, b) => b[1] - a[1]);
            const userReaction = reactions.find(r => r.user_id === currentUser.id);
            const reactionSummaryHtml = sortedReactions.map(([type, count]) => `<div class="reaction-pill ${userReaction?.reaction_type === type ? 'user-reacted' : ''}"><span>${type}</span><span class="font-bold ml-1">${count}</span></div>`).join('');
            
            div.innerHTML = `
                <div><a href="profile.html?user_id=${profile.id}"><img src="${profilePicUrl}" alt="Profile Picture" class="w-12 h-12 rounded-full bg-gray-200" loading="lazy"></a></div>
                <div class="w-full">
                    <div class="flex justify-between items-start">
                        <div>
                            <a href="profile.html?user_id=${profile.id}" class="hover:underline">
                                <p class="font-bold flex items-center">${profile.full_name} ${profile.is_verified ? '<span class="ml-1 text-blue-500"><i class="bi bi-patch-check-fill"></i></span>' : ''}
                                <span class="ml-2 text-sm text-gray-500 font-normal">@${profile.username}</span></p>
                            </a>
                            <p class="text-xs text-gray-500">${new Date(post.created_at).toLocaleString('id-ID', { dateStyle: 'short', timeStyle: 'short' })}</p>
                        </div>
                        ${post.user_id === currentUser.id ? `<button data-post-id="${post.id}" class="delete-post-button text-gray-400 hover:text-red-500 text-xl">&times;</button>` : ''}
                    </div>
                    ${copiedLabelHtml}
                    ${postContentHtml}
                    <div class="reaction-summary">${reactionSummaryHtml}</div>
                    <div class="flex items-center justify-around text-gray-500 mt-3">
                        <button data-post-id="${post.id}" class="comment-button flex items-center space-x-1 icon-btn hover:text-blue-500 interactive-btn"><i class="bi bi-chat text-xl"></i><span class="comment-count">${commentCount}</span></button>
                        <button data-post-id="${post.id}" data-liked="${userHasLiked}" class="like-button flex items-center space-x-1 icon-btn ${userHasLiked ? 'text-red-500' : 'hover:text-red-500'} interactive-btn"><i class="bi ${userHasLiked ? 'bi-heart-fill' : 'bi-heart'} text-xl"></i><span class="like-count">${likeCount}</span></button>
                        <button data-post-id="${post.id}" class="copy-link-button icon-btn hover:text-green-500 interactive-btn"><i class="bi bi-link-45deg text-xl"></i></button>
                        <div data-post-id="${post.id}" class="reactions-container relative">
                            <button class="icon-btn hover:text-yellow-500 ${userReaction ? 'text-yellow-500' : ''} interactive-btn"><i class="bi bi-emoji-smile text-xl"></i></button>
                        </div>
                    </div>
                </div>`;
            
            const video = div.querySelector('video');
            if (video) {
                const playPauseIcon = div.querySelector('.play-pause-btn i');
                video.addEventListener('play', () => {
                    if(playPauseIcon) playPauseIcon.className = 'bi bi-pause-fill text-3xl';
                });
                video.addEventListener('pause', () => {
                    if(playPauseIcon) playPauseIcon.className = 'bi bi-play-fill text-3xl';
                });
            }

            return div;
        }

        async function updatePostReactionsUI(postId, elementContext = null) {
            const postElement = elementContext ? elementContext.querySelector(`[id='post-${postId}']`) : document.getElementById(`post-${postId}`);
            if (!postElement) return;
            const { data: reactions, error } = await db.from('reactions').select('*').eq('post_id', postId);
            if (error) return;
            const reactionCounts = reactions.reduce((acc, reaction) => {
                acc[reaction.reaction_type] = (acc[reaction.reaction_type] || 0) + 1;
                return acc;
            }, {});
            const sortedReactions = Object.entries(reactionCounts).sort((a, b) => b[1] - a[1]);
            const userReaction = reactions.find(r => r.user_id === currentUser.id);
            const summaryContainer = postElement.querySelector('.reaction-summary');
            if (summaryContainer) {
                summaryContainer.innerHTML = sortedReactions.map(([type, count]) => `<div class="reaction-pill ${userReaction?.reaction_type === type ? 'user-reacted' : ''}"><span>${type}</span><span class="font-bold ml-1">${count}</span></div>`).join('');
            }
            const reactionButton = postElement.querySelector('.reactions-container button');
            if (reactionButton) {
                reactionButton.classList.toggle('text-yellow-500', !!userReaction);
            }
        }
        
        function updatePollUI(postId, pollOptions, pollVotes, elementContext = document) {
            const pollContainer = elementContext.querySelector(`#poll-${postId}`);
            if (!pollContainer) {
                console.log(`[updatePollUI] Could not find poll container for post ${postId} in context`, elementContext);
                return;
            }

            const userVote = (pollVotes || []).find(v => v.user_id === currentUser.id);
            const totalVotes = (pollOptions || []).reduce((sum, opt) => sum + opt.votes, 0);

            pollContainer.querySelectorAll('.poll-option').forEach(optionEl => {
                const optionText = optionEl.dataset.option;
                const optionData = pollOptions.find(o => o.option === optionText);
                if (!optionData) return;

                const hasVotedThis = userVote && userVote.option_text === optionText;
                optionEl.classList.toggle('user-voted', hasVotedThis);

                const percent = totalVotes > 0 ? Math.round((optionData.votes / totalVotes) * 100) : 0;
                
                let progressEl = optionEl.querySelector('.poll-progress');
                let percentEl = optionEl.querySelector('.poll-option-percent');
                const contentEl = optionEl.querySelector('.poll-option-content');

                if (userVote) {
                    if (!progressEl) {
                        progressEl = document.createElement('div');
                        progressEl.className = 'poll-progress';
                        optionEl.prepend(progressEl);
                    }
                    if (!percentEl) {
                        percentEl = document.createElement('span');
                        percentEl.className = 'poll-option-percent';
                        if(contentEl) contentEl.appendChild(percentEl);
                    }
                    
                    percentEl.textContent = `${percent}%`;

                    setTimeout(() => {
                        if (progressEl) progressEl.style.width = `${percent}%`;
                    }, 10);

                } else {
                    if (progressEl) {
                        progressEl.style.width = '0%';
                        progressEl.addEventListener('transitionend', () => progressEl.remove(), { once: true });
                    }
                    if (percentEl) {
                        percentEl.remove();
                    }
                }
            });

            const totalVotesEl = pollContainer.querySelector('.text-right');
            if(totalVotesEl) totalVotesEl.textContent = `${totalVotes} suara`;
        }


        function createCommentElement(comment, profile, postOwnerId, replyCount = 0) {
            const div = document.createElement('div');
            div.className = `flex space-x-3 mt-4 comment-container ${comment.is_pinned ? 'comment-pinned' : ''}`;
            div.id = `comment-${comment.id}`;

            const userInitial = profile.full_name.charAt(0).toUpperCase();
            const profilePicUrl = profile.profile_avatar_url || `https://placehold.co/40x40/1A1A1A/FFFFFF?text=${userInitial}&font=inter`;
            const liked_by = comment.liked_by || [];
            const userHasLiked = liked_by.includes(currentUser.id);
            const likeCount = liked_by.length;
            const isPostOwner = currentUser.id === postOwnerId;
            const isCommentOwner = currentUser.id === comment.user_id;
            
            let replyToMentionSpan = '';
            if (comment.reply_to_username) {
                replyToMentionSpan = `<a href="#" class="text-blue-500 hover:underline mr-1">@${comment.reply_to_username}</a>`;
            }

            const processedContent = comment.content.replace(/@(\w+)/g, '<a href="#" class="text-blue-500 hover:underline">@$1</a>');

            const repliesContainerHtml = `<div class="replies-container hidden pl-10"></div>`;
            const showRepliesButton = replyCount > 0 ? `<button class="toggle-replies-button text-sm text-blue-500 font-semibold mt-2">Lihat ${replyCount} balasan</button>` : '';

            div.innerHTML = `
                <img src="${profilePicUrl}" loading="lazy" class="w-10 h-10 rounded-full bg-gray-200 flex-shrink-0">
                <div class="flex-1">
                    <div class="bg-gray-100 rounded-xl p-3">
                        ${comment.is_pinned ? '<div class="text-xs text-gray-500 font-semibold mb-2 flex items-center"><i class="bi bi-pin-angle-fill mr-1.5"></i>Disematkan oleh Pemilik</div>' : ''}
                        <div class="flex justify-between items-center">
                            <a href="profile.html?user_id=${profile.id}" class="font-bold hover:underline text-sm flex items-center">
                                ${profile.full_name} ${profile.is_verified ? '<span class="ml-1 text-blue-400 text-xs"><i class="bi bi-patch-check-fill"></i></span>' : ''}
                            </a>
                            <div class="flex items-center text-gray-400">
                                ${isPostOwner && !comment.parent_comment_id ? `<button class="pin-comment-button p-1 hover:text-blue-500" data-comment-id="${comment.id}" data-pinned="${comment.is_pinned}"><i class="bi bi-pin-angle"></i></button>` : ''}
                                ${isCommentOwner || isPostOwner ? `<button class="delete-comment-button p-1 hover:text-red-500" data-comment-id="${comment.id}"><i class="bi bi-trash"></i></button>` : ''}
                            </div>
                        </div>
                        <p class="text-sm mt-1">${replyToMentionSpan}${processedContent}</p>
                    </div>
                    <div class="flex items-center space-x-4 text-xs text-gray-500 mt-1 pl-2">
                        <button data-comment-id="${comment.id}" data-liked="${userHasLiked}" class="like-comment-button flex items-center space-x-1 font-semibold ${userHasLiked ? 'text-red-500' : 'hover:text-red-500'} interactive-btn">
                            <i class="bi ${userHasLiked ? 'bi-heart-fill' : 'bi-heart'}"></i><span>Suka</span>(<span class="comment-like-count">${likeCount}</span>)
                        </button>
                        <button class="reply-button font-semibold hover:underline interactive-btn" data-comment-id="${comment.id}" data-username="${profile.username}">Balas</button>
                        <span>${new Date(comment.created_at).toLocaleTimeString('id-ID', { hour: '2-digit', minute:'2-digit' })}</span>
                    </div>
                    ${showRepliesButton}
                    ${repliesContainerHtml}
                </div>`;
            return div;
        }

        async function updatePostPollData(postId) {
            console.log(`[Aggregation] Fetching all votes for post [${postId}]...`);
            
            // 1. Get all votes for the post
            const { data: allVotes, error: votesError } = await db
                .from('poll_votes')
                .select('option_text')
                .eq('post_id', postId);

            if (votesError) {
                console.error('[Aggregation] Error fetching votes:', votesError);
                return;
            }
            console.log(`[Aggregation] Found ${allVotes.length} total votes.`);

            // 2. Get the original post data (for the options template)
            const { data: post, error: postError } = await db
                .from('posts')
                .select('poll_options')
                .eq('id', postId)
                .single();
            
            if (postError) {
                console.error('[Aggregation] Error fetching post data:', postError);
                return;
            }

            // 3. Recalculate counts
            const newPollOptions = post.poll_options.map(option => ({
                ...option,
                votes: 0 // Reset votes to 0 before recounting
            }));

            allVotes.forEach(vote => {
                const optionToUpdate = newPollOptions.find(opt => opt.option === vote.option_text);
                if (optionToUpdate) {
                    optionToUpdate.votes++;
                }
            });
            console.log('[Aggregation] Recalculated vote counts:', newPollOptions);

            // 4. Update the posts table
            console.log(`[Aggregation] Updating post [${postId}] with new vote counts.`);
            const { error: updateError } = await db
                .from('posts')
                .update({ poll_options: newPollOptions })
                .eq('id', postId);

            if (updateError) {
                console.error('[Aggregation] Error updating post table:', updateError);
            } else {
                console.log('[Aggregation] Post table successfully updated. Realtime event should now trigger for all clients.');
            }
        }


        async function openCommentModal(postId) {
            document.querySelectorAll('#timeline video').forEach(v => {
                if (window.videoObserver) window.videoObserver.unobserve(v);
                v.pause();
                v.muted = true;
                const player = v.closest('.custom-video-player');
                if (player) {
                    const volumeIcon = player.querySelector('.volume-btn i');
                    if (volumeIcon) volumeIcon.className = 'bi bi-volume-mute-fill';
                }
            });

            // --- START FIX: Use the new skeleton loader ---
            modalContent.innerHTML = createCommentSkeletonLoader();
            // --- END FIX ---

            commentModal.classList.remove('hidden');
            commentModal.classList.add('flex');
            setTimeout(() => commentModal.classList.add('is-visible'), 10);
            
            const { data: post, error: postError } = await db.from('posts').select(`*, profiles(*), likes(user_id), reactions(*), comments(count), poll_votes(user_id, option_text)`).eq('id', postId).single();
            if (postError) { modalContent.innerHTML = '<p>Gagal memuat postingan.</p>'; return; }
            activePostForComment = post;

            const { data: comments, error: commentsError } = await db.from('comments').select(`*`).eq('post_id', postId);
            if (commentsError) { modalContent.innerHTML = '<p>Gagal memuat komentar.</p>'; return; }
            
            commentsById.clear();
            comments.forEach(c => commentsById.set(c.id, c));

            const userIds = [...new Set(comments.map(c => c.user_id))];
            const { data: profiles, error: profilesError } = await db.from('profiles').select('*').in('id', userIds);
            if (profilesError) { modalContent.innerHTML = '<p>Gagal memuat profil.</p>'; return; }
            const profilesMap = new Map(profiles.map(p => [p.id, p]));

            const rootComments = [];
            const repliesByParent = new Map();

            comments.forEach(c => {
                if (c.parent_comment_id) {
                    let rootParentId = c.parent_comment_id;
                    let current = commentsById.get(rootParentId);
                    while(current && current.parent_comment_id) {
                        rootParentId = current.parent_comment_id;
                        current = commentsById.get(rootParentId);
                    }

                    if (!repliesByParent.has(rootParentId)) {
                        repliesByParent.set(rootParentId, []);
                    }
                    repliesByParent.get(rootParentId).push(c);
                } else {
                    rootComments.push(c);
                }
            });

            rootComments.sort((a, b) => b.is_pinned - a.is_pinned || new Date(a.created_at) - new Date(b.created_at));

            const postElement = createPostElement(post); 
            postElement.classList.remove('border-b');

            const commentListContainer = document.createElement('div');
            commentListContainer.id = 'comment-list';

            rootComments.forEach(comment => {
                const profile = profilesMap.get(comment.user_id);
                if (!profile) return;
                
                const replies = repliesByParent.get(comment.id) || [];
                replies.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));

                const rootCommentElement = createCommentElement(comment, profile, post.user_id, replies.length);
                commentListContainer.appendChild(rootCommentElement);
                
                const repliesContainer = rootCommentElement.querySelector('.replies-container');

                replies.forEach(reply => {
                    const replyProfile = profilesMap.get(reply.user_id);
                    if (!replyProfile) return;
                    
                    const replyCommentElement = createCommentElement(reply, replyProfile, post.user_id);
                    repliesContainer.appendChild(replyCommentElement);
                });
            });


            modalContent.innerHTML = '';
            modalContent.appendChild(postElement);
            const hr = document.createElement('hr');
            hr.className = 'my-4';
            modalContent.appendChild(hr);
            modalContent.appendChild(commentListContainer);
            
            const videoInModal = modalContent.querySelector('video');
            if (videoInModal) {
                videoInModal.muted = false;
                const volumeIcon = modalContent.querySelector('.volume-btn i');
                if(volumeIcon) volumeIcon.className = 'bi bi-volume-up-fill';
                videoInModal.play().catch(e => {});
            }
        }

        async function parseMentions(text) {
            const mentionRegex = /@(\w+)/g;
            const mentions = text.match(mentionRegex);
            if (!mentions) return { ids: [], usernames: [] };
            const usernames = [...new Set(mentions.map(m => m.substring(1)))];
            const { data, error } = await db.from('profiles').select('id, username').in('username', usernames);
            if (error) {
                console.error("Error fetching mentioned user IDs:", error.message || error);
                return { ids: [], usernames: [] };
            }
            return {
                ids: data.map(u => u.id),
                usernames: data.map(u => u.username)
            };
        }
        
        function setupMentionHandler(inputElement, popupElement) {
            let mentionQuery = '';
            let mentionStartIndex = -1;
            inputElement.addEventListener('input', async (e) => {
                const text = e.target.value;
                const cursorPos = e.target.selectionStart;
                const atIndex = text.lastIndexOf('@', cursorPos - 1);
                if (atIndex > -1 && (atIndex === 0 || /\s/.test(text[atIndex - 1]))) {
                    const query = text.substring(atIndex + 1, cursorPos);
                    if (!/\s/.test(query)) {
                        mentionQuery = query;
                        mentionStartIndex = atIndex;
                        const { data: users } = await db.from('profiles').select('username, full_name, profile_avatar_url').ilike('username', `${query}%`).neq('id', currentUser.id).limit(5);
                        if (users && users.length > 0) {
                            popupElement.innerHTML = users.map(user => `
                                <div class="mention-item" data-username="${user.username}">
                                    <img src="${user.profile_avatar_url || 'https://placehold.co/40x40'}" class="w-8 h-8 rounded-full mr-2">
                                    <div><p class="font-semibold">${user.full_name}</p><p class="text-sm text-gray-500">@${user.username}</p></div>
                                </div>`).join('');
                            popupElement.classList.remove('hidden');
                        } else {
                            popupElement.classList.add('hidden');
                        }
                    } else {
                       popupElement.classList.add('hidden');
                    }
                } else {
                    popupElement.classList.add('hidden');
                }
            });
            popupElement.addEventListener('click', (e) => {
                const item = e.target.closest('.mention-item');
                if (item) {
                    const username = item.dataset.username;
                    const currentText = inputElement.value;
                    const newText = currentText.substring(0, mentionStartIndex) + `@${username} ` + currentText.substring(inputElement.selectionStart);
                    inputElement.value = newText;
                    popupElement.classList.add('hidden');
                    inputElement.focus();
                }
            });
        }

        setupMentionHandler(postContentInput, document.getElementById('post-mention-popup'));
        setupMentionHandler(commentInput, document.getElementById('comment-mention-popup'));
        postContentInput.addEventListener('input', () => submitPostButton.disabled = !postContentInput.value.trim() && !postImageFile && !postVideoFile);
        
        function handleMediaUpload(event, mediaType) {
            const file = event.target.files[0];
            if (!file) return;
            resetComposerStyle();
            postImageFile = mediaType === 'image' ? file : null;
            postVideoFile = mediaType === 'video' ? file : null;
            imageUploadInput.value = '';
            videoUploadInput.value = '';
            const reader = new FileReader();
            reader.onload = (e) => {
                let previewHtml = '';
                if (mediaType === 'image') {
                    previewHtml = `<div class="preview-container"><img src="${e.target.result}" class="rounded-2xl max-h-80"><button class="remove-media-btn">&times;</button></div>`;
                } else {
                    previewHtml = `<div class="preview-container"><video src="${e.target.result}" class="rounded-2xl max-h-80" muted loop autoplay></video><button class="remove-media-btn">&times;</button></div>`;
                }
                mediaPreviewContainer.innerHTML = previewHtml;
                mediaPreviewContainer.querySelector('.remove-media-btn').onclick = () => {
                    postImageFile = null;
                    postVideoFile = null;
                    mediaPreviewContainer.innerHTML = '';
                    submitPostButton.disabled = !postContentInput.value.trim();
                };
            };
            reader.readAsDataURL(file);
            submitPostButton.disabled = false;
        }

        imageUploadInput.addEventListener('change', (e) => handleMediaUpload(e, 'image'));
        videoUploadInput.addEventListener('change', (e) => handleMediaUpload(e, 'video'));
        
        submitPostButton.addEventListener('click', async () => {
            const content = postContentInput.value.trim();
            if (!content && !postImageFile && !postVideoFile) return;
            submitPostButton.disabled = true;
            submitPostButton.textContent = 'Memposting...';

            const { ids: mentionedUserIds } = await parseMentions(content);
            const hashtags = content.match(/#(\w+)/g)?.map(h => h.substring(1).toLowerCase()) || [];

            let imageUrl = null, videoUrl = null;
            const fileToUpload = postImageFile || postVideoFile;
            if (fileToUpload && !isFullTextMode) {
                const fileName = `${currentUser.id}/${Date.now()}`;
                const { error: uploadError } = await db.storage.from('media').upload(fileName, fileToUpload);
                if (uploadError) { 
                    console.error('Error uploading media:', uploadError.message || error); 
                    submitPostButton.disabled = false; submitPostButton.textContent = 'Posting'; return; 
                }
                const { data: urlData } = db.storage.from('media').getPublicUrl(fileName);
                if (postImageFile) imageUrl = urlData.publicUrl;
                if (postVideoFile) videoUrl = urlData.publicUrl;
            }
            const postData = { 
                content, 
                user_id: currentUser.id, 
                image_url: imageUrl, 
                video_url: videoUrl, 
                is_full_text: isFullTextMode, 
                bg_color: fullTextColor, 
                font_family: fullTextFont, 
                mentioned_users: mentionedUserIds,
                hashtags: hashtags 
            };
            const { data: newPost, error: insertError } = await db.from('posts').insert(postData).select().single();
            if (insertError) {
                console.error('Error creating post:', insertError.message || JSON.stringify(insertError, null, 2));
            } else {
                 if (mentionedUserIds.length > 0) {
                    const notifications = mentionedUserIds.map(userId => ({ recipient_id: userId, actor_id: currentUser.id, notification_type: 'mention_post', post_id: newPost.id }));
                    await db.from('notifications').insert(notifications);
                }
                postContentInput.value = '';
                postImageFile = null; postVideoFile = null;
                mediaPreviewContainer.innerHTML = '';
                resetComposerStyle();
                await fetchPosts();
            }
            submitPostButton.disabled = !postContentInput.value.trim();
            submitPostButton.textContent = 'Posting';
        });

        document.body.addEventListener('click', async (e) => {
            const player = e.target.closest('.custom-video-player');
            if (player) {
                const video = player.querySelector('video');
                const playBtnIcon = player.querySelector('.play-pause-btn i');
                const volumeBtn = e.target.closest('.volume-btn');
                if (volumeBtn) {
                    const volumeIcon = volumeBtn.querySelector('i');
                    video.muted = !video.muted;
                    volumeIcon.className = video.muted ? 'bi bi-volume-mute-fill' : 'bi bi-volume-up-fill';
                    return;
                }
                const progressBar = e.target.closest('.video-progress-bar');
                if (progressBar) {
                     const rect = progressBar.getBoundingClientRect();
                     const clickX = e.clientX - rect.left;
                     const newTime = (clickX / rect.width) * video.duration;
                     video.currentTime = newTime;
                     return;
                }
                if (video.paused) {
                    video.play();
                } else {
                    video.pause();
                }
            }
            
            const pollOption = e.target.closest('.poll-option');
            if (pollOption) {
                if (pollOption.getAttribute('data-processing') === 'true') {
                    console.log('Poll vote is already being processed. Please wait.');
                    return;
                }

                // --- START: OPTIMISTIC UI UPDATE ---
                console.log('[Optimistic] Applying instant visual feedback.');
                const pollContainer = pollOption.closest('.poll-container');
                const wasAlreadyVoted = pollOption.classList.contains('user-voted');
                
                // Remove highlighting and results from all options
                pollContainer.querySelectorAll('.poll-option').forEach(opt => opt.classList.remove('user-voted'));
                pollContainer.querySelectorAll('.poll-progress, .poll-option-percent').forEach(el => el.remove());

                // If the user is selecting a new option (or voting for the first time)
                if (!wasAlreadyVoted) {
                    pollOption.classList.add('user-voted');
                    console.log('[Optimistic] Highlighted new option:', pollOption.dataset.option);
                } else {
                    console.log('[Optimistic] De-highlighted option for un-vote:', pollOption.dataset.option);
                }
                // --- END: OPTIMISTIC UI UPDATE ---

                pollOption.setAttribute('data-processing', 'true');
                console.log('--- Poll Vote Initiated (background) ---');
                const postId = pollOption.dataset.postId;
                const optionText = pollOption.dataset.option;
                const userId = currentUser.id;

                console.log(`User [${userId}] clicked option "${optionText}" for post [${postId}]`);

                try {
                    const { data: existingVote, error: findError } = await db
                        .from('poll_votes')
                        .select('id, option_text')
                        .eq('post_id', postId)
                        .eq('user_id', userId)
                        .maybeSingle();

                    if (findError) throw findError;

                    if (existingVote) {
                        if (existingVote.option_text === optionText) {
                            console.log('Existing vote found for the same option. Removing vote.');
                            const { error: deleteError } = await db.from('poll_votes').delete().eq('id', existingVote.id);
                            if (deleteError) throw deleteError;
                            console.log('Vote successfully removed from poll_votes.');
                        } else {
                            console.log(`Existing vote found for a different option ("${existingVote.option_text}"). Changing vote.`);
                            const { error: updateError } = await db.from('poll_votes').update({ option_text: optionText }).eq('id', existingVote.id);
                            if (updateError) throw updateError;
                            console.log('Vote successfully changed in poll_votes.');
                        }
                    } else {
                        console.log('No existing vote found. Creating new vote.');
                        const { error: insertError } = await db.from('poll_votes').insert({ post_id: postId, user_id: userId, option_text: optionText });
                        if (insertError) throw insertError;
                        console.log('Vote successfully created in poll_votes.');
                    }

                    await updatePostPollData(postId);

                } catch (error) {
                    console.error("Error processing poll vote:", error);
                    showToast("Gagal memproses suara Anda.");
                } finally {
                    pollOption.removeAttribute('data-processing');
                    console.log('--- Poll Vote Process Finished ---');
                }
            }

            const copyLinkButton = e.target.closest('.copy-link-button');
            if(copyLinkButton) {
                const postId = copyLinkButton.dataset.postId;
                const postUrl = `${window.location.origin}${window.location.pathname}?post_id=${postId}`;
                try {
                    await navigator.clipboard.writeText(postUrl);
                    showToast('Tautan disalin ke clipboard!');
                    const { error } = await db.rpc('repost_post', { post_id_to_repost: postId });
                    if(error) throw error;
                    
                    // --- START FIX: Smartly move post to top instead of full refresh ---
                    const postElement = document.getElementById(`post-${postId}`);
                    if (postElement) {
                        // Add animation class for smooth transition
                        postElement.classList.add('post-enter-animation');
                        timeline.prepend(postElement);
                    }
                    // --- END FIX ---
                } catch(err) {
                    console.error('Gagal menyalin atau memposting ulang:', err);
                    showToast('Gagal menyalin tautan.');
                }
            }

            const reactionEmoji = e.target.closest('.reaction-emoji');
            if (reactionEmoji) {
                const postId = globalReactionPopover.dataset.postId;
                if (!postId) return;

                const reactionType = reactionEmoji.dataset.reaction;
                db.rpc('toggle_reaction', { post_id_to_toggle: postId, reaction_to_set: reactionType })
                  .then(({error}) => {
                    if (error) console.error("Gagal mengirim reaksi:", error);
                    else {
                        updatePostReactionsUI(postId);
                         if (commentModal.classList.contains('is-visible') && activePostForComment?.id == postId) {
                           updatePostReactionsUI(postId, modalContent);
                        }
                    }
                  });
                globalReactionPopover.classList.remove('visible'); // Hide after clicking
            }
            
            const likeButton = e.target.closest('.like-button:not(.like-comment-button)');
            if (likeButton) {
                const postId = likeButton.dataset.postId;
                if(likeButton.disabled) return;
                likeButton.disabled = true;

                recentlyUpdatedPostLikes.add(postId);
                setTimeout(() => recentlyUpdatedPostLikes.delete(postId), 2000);

                const wasLiked = likeButton.dataset.liked === 'true';
                const likeCountSpan = likeButton.querySelector('.like-count');
                const icon = likeButton.querySelector('i');
                const currentCount = parseInt(likeCountSpan.textContent);
                
                likeButton.dataset.liked = !wasLiked;
                likeCountSpan.textContent = wasLiked ? currentCount - 1 : currentCount + 1;
                likeButton.classList.toggle('text-red-500', !wasLiked);
                icon.classList.toggle('bi-heart-fill', !wasLiked);
                icon.classList.toggle('bi-heart', wasLiked);
                
                db.rpc('toggle_like', { user_id_to_toggle: currentUser.id, post_id_to_toggle: postId })
                    .then(({ error }) => {
                        if (error) {
                            console.error('Gagal menyukai postingan, mengembalikan UI.', error);
                            likeButton.dataset.liked = wasLiked;
                            likeCountSpan.textContent = currentCount;
                            likeButton.classList.toggle('text-red-500', wasLiked);
                            icon.classList.toggle('bi-heart-fill', wasLiked);
                            icon.classList.toggle('bi-heart', !wasLiked);
                            recentlyUpdatedPostLikes.delete(postId);
                        }
                    }).finally(() => {
                        likeButton.disabled = false;
                    });
            }

            const commentButton = e.target.closest('.comment-button');
            if (commentButton) openCommentModal(commentButton.dataset.postId);
            const deleteButton = e.target.closest('.delete-post-button');
            if (deleteButton) {
                showConfirmModal(
                    'Postingan ini akan dihapus secara permanen dan tidak dapat dikembalikan.',
                    () => {
                        db.from('posts').delete().eq('id', deleteButton.dataset.postId)
                          .then(({error}) => {
                             if (error) console.error('Error deleting post:', error.message || error);
                             else document.getElementById(`post-${deleteButton.dataset.postId}`).remove();
                          });
                    }
                );
            }
        });

        document.body.addEventListener('mouseover', e => {
            const reactionContainer = e.target.closest('.reactions-container');
            if (reactionContainer) {
                clearTimeout(reactionPopoverTimeout);
                const rect = reactionContainer.getBoundingClientRect();
                const postId = reactionContainer.dataset.postId;
                
                globalReactionPopover.dataset.postId = postId;

                const popoverWidth = globalReactionPopover.offsetWidth;
                const windowWidth = window.innerWidth;
                
                let leftPos = rect.left + (rect.width / 2) - (popoverWidth / 2);
                
                const margin = 8;
                if (leftPos < margin) {
                    leftPos = margin;
                }
                if (leftPos + popoverWidth > windowWidth - margin) {
                    leftPos = windowWidth - popoverWidth - margin;
                }
                
                globalReactionPopover.style.left = `${leftPos}px`;
                globalReactionPopover.style.top = `${rect.top - 45}px`;
                globalReactionPopover.classList.add('visible');
            }
        });

        document.body.addEventListener('mouseout', e => {
            const reactionContainer = e.target.closest('.reactions-container');
             if (reactionContainer) {
                reactionPopoverTimeout = setTimeout(() => {
                    if (!globalReactionPopover.matches(':hover')) {
                        globalReactionPopover.classList.remove('visible');
                    }
                }, 200);
            }
        });

        globalReactionPopover.addEventListener('mouseleave', () => {
             globalReactionPopover.classList.remove('visible');
        });

        timeline.addEventListener('timeupdate', e => {
             if (e.target.tagName === 'VIDEO') {
                const player = e.target.closest('.custom-video-player');
                if (!player) return;
                const progressFilled = player.querySelector('.video-progress-filled');
                const progress = (e.target.currentTime / e.target.duration) * 100;
                progressFilled.style.width = `${progress}%`;
             }
        }, true);
        
        fullTextStyleButton.addEventListener('click', () => { fullTextModal.classList.remove('hidden'); fullTextModal.classList.add('flex'); });
        closeFullTextModalButton.addEventListener('click', () => { fullTextModal.classList.add('hidden'); fullTextModal.classList.remove('flex'); });
        colorSwatches.addEventListener('click', (e) => { const button = e.target.closest('button'); if (!button) return; isFullTextMode = true; fullTextColor = button.dataset.color; updateComposerFullTextStyle(); closeFullTextModalButton.click(); });
        fontSwatches.addEventListener('click', (e) => { const button = e.target.closest('button'); if (!button) return; isFullTextMode = true; fullTextFont = button.dataset.font || 'font-inter'; updateComposerFullTextStyle(); closeFullTextModalButton.click(); });
        
        function addPollOptionInput(value = '') {
            const optionDiv = document.createElement('div');
            optionDiv.className = 'flex items-center space-x-2';
            optionDiv.innerHTML = `
                <input type="text" value="${value}" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-1 focus:ring-black" placeholder="Opsi">
                <button class="remove-poll-option text-red-500 hover:text-red-700 text-xl">&times;</button>
            `;
            pollOptionsContainer.appendChild(optionDiv);
            optionDiv.querySelector('.remove-poll-option').addEventListener('click', () => {
                if (pollOptionsContainer.children.length > 2) {
                    optionDiv.remove();
                    validatePollForm();
                }
            });
            optionDiv.querySelector('input').addEventListener('input', validatePollForm);
        }

        function validatePollForm() {
            const question = pollQuestionInput.value.trim();
            const options = Array.from(pollOptionsContainer.querySelectorAll('input')).map(input => input.value.trim());
            const hasEmptyOption = options.some(opt => opt === '');
            submitPollPostButton.disabled = question === '' || options.length < 2 || hasEmptyOption;
        }

        pollButton.addEventListener('click', () => {
            pollModal.classList.remove('hidden');
            pollModal.classList.add('flex');
            setTimeout(() => pollModal.classList.add('is-visible'), 10);
            pollOptionsContainer.innerHTML = '';
            addPollOptionInput();
            addPollOptionInput();
            validatePollForm();
        });

        closePollModalButton.addEventListener('click', () => {
            pollModal.classList.remove('is-visible');
            setTimeout(() => {
                pollModal.classList.add('hidden');
                pollModal.classList.remove('flex');
            }, 250);
        });
        
        addPollOptionButton.addEventListener('click', () => {
            if (pollOptionsContainer.children.length < 5) {
                addPollOptionInput();
                validatePollForm();
            }
        });
        
        pollQuestionInput.addEventListener('input', validatePollForm);

        submitPollPostButton.addEventListener('click', async () => {
            const question = pollQuestionInput.value.trim();
            const options = Array.from(pollOptionsContainer.querySelectorAll('input'))
                               .map(input => input.value.trim())
                               .filter(opt => opt !== '');
            if(question === '' || options.length < 2) return;

            submitPollPostButton.disabled = true;
            submitPollPostButton.textContent = 'Memposting...';

            const pollOptionsData = options.map(opt => ({ option: opt, votes: 0 }));

            const postData = {
                user_id: currentUser.id,
                content: '',
                is_poll: true,
                poll_question: question,
                poll_options: pollOptionsData
            };
            
            const { error } = await db.from('posts').insert(postData);
            if(error) {
                console.error('Gagal membuat polling:', error);
                showToast('Gagal membuat polling.');
            } else {
                showToast('Polling berhasil dibuat!');
                closePollModalButton.click();
                await fetchPosts();
            }
            submitPollPostButton.disabled = false;
            submitPollPostButton.textContent = 'Posting Polling';
        });
        
        modalContent.addEventListener('click', async (e) => {
            const replyBtn = e.target.closest('.reply-button');
            if (replyBtn) {
                const repliedToCommentId = replyBtn.dataset.commentId;
                const repliedToUsername = replyBtn.dataset.username;

                const repliedToComment = commentsById.get(repliedToCommentId);
                let newParentId = repliedToCommentId;
                let current = repliedToComment;
                while (current && current.parent_comment_id) {
                    newParentId = current.parent_comment_id;
                    current = commentsById.get(newParentId);
                }

                activeReplyTo = { 
                    parentId: newParentId,
                    replyToUsernameForDisplay: repliedToUsername
                };

                replyingToBanner.innerHTML = `Membalas <strong>@${activeReplyTo.replyToUsernameForDisplay}</strong> <button class="font-bold ml-2" id="cancel-reply-btn">&times;</button>`;
                replyingToBanner.classList.remove('hidden');
                commentInput.focus();
                document.getElementById('cancel-reply-btn').onclick = () => { activeReplyTo = null; replyingToBanner.classList.add('hidden'); };
            }

            const toggleBtn = e.target.closest('.toggle-replies-button');
            if (toggleBtn) {
                const repliesContainer = toggleBtn.nextElementSibling;
                if (repliesContainer) {
                    repliesContainer.classList.toggle('hidden');
                    const isHidden = repliesContainer.classList.contains('hidden');
                    const replyCount = toggleBtn.textContent.match(/\d+/)[0];
                    toggleBtn.textContent = isHidden ? `Lihat ${replyCount} balasan` : 'Sembunyikan balasan';
                }
            }
            
            const likeCommentBtn = e.target.closest('.like-comment-button');
            if (likeCommentBtn) {
                const commentId = likeCommentBtn.dataset.commentId;
                if(likeCommentBtn.disabled) return;
                likeCommentBtn.disabled = true;

                recentlyUpdatedCommentLikes.add(commentId);
                setTimeout(() => recentlyUpdatedCommentLikes.delete(commentId), 2000);

                const wasLiked = likeCommentBtn.dataset.liked === 'true';
                const countSpan = likeCommentBtn.querySelector('.comment-like-count');
                const icon = likeCommentBtn.querySelector('i');
                const originalCount = parseInt(countSpan.textContent);

                likeCommentBtn.dataset.liked = !wasLiked;
                countSpan.textContent = wasLiked ? originalCount - 1 : originalCount + 1;
                likeCommentBtn.classList.toggle('text-red-500', !wasLiked);
                icon.classList.toggle('bi-heart-fill', !wasLiked);
                icon.classList.toggle('bi-heart', wasLiked);
                
                try {
                    const { error } = await db.rpc('toggle_comment_like', {
                        comment_id_to_toggle: commentId,
                        user_id_to_toggle: currentUser.id
                    });
                    if (error) throw error;
                } catch(error) {
                    console.error('Error updating comment like:', error.message || error);
                    likeCommentBtn.dataset.liked = wasLiked;
                    countSpan.textContent = originalCount;
                    likeCommentBtn.classList.toggle('text-red-500', wasLiked);
                    icon.classList.toggle('bi-heart-fill', wasLiked);
                    icon.classList.toggle('bi-heart', !wasLiked);
                    recentlyUpdatedCommentLikes.delete(commentId);
                } finally {
                    likeCommentBtn.disabled = false;
                }
            }
            const pinCommentBtn = e.target.closest('.pin-comment-button');
            if(pinCommentBtn) {
                const commentId = pinCommentBtn.dataset.commentId;
                const isPinned = !(pinCommentBtn.dataset.pinned === 'true');
                await db.from('comments').update({ is_pinned: isPinned }).eq('id', commentId);
                await openCommentModal(activePostForComment.id);
            }
            const deleteCommentBtn = e.target.closest('.delete-comment-button');
            if(deleteCommentBtn) {
                showConfirmModal(
                    'Komentar ini akan dihapus secara permanen.',
                    async () => {
                        await db.from('comments').delete().eq('id', deleteCommentBtn.dataset.commentId);
                        await openCommentModal(activePostForComment.id);
                    }
                );
            }
        });

        submitCommentButton.addEventListener('click', async () => {
            const content = commentInput.value.trim();
            if (!content || !activePostForComment) return;
            submitCommentButton.disabled = true;
            
            const postElementOnTimeline = document.getElementById(`post-${activePostForComment.id}`);
            if (postElementOnTimeline) {
                const countSpan = postElementOnTimeline.querySelector('.comment-count');
                countSpan.textContent = parseInt(countSpan.textContent) + 1;
            }

            const { ids: mentionedUserIds } = await parseMentions(content);
            
            const parentCommentId = activeReplyTo ? activeReplyTo.parentId : null;
            const replyToUsername = activeReplyTo ? activeReplyTo.replyToUsernameForDisplay : null;

            const { data: newComment, error } = await db.from('comments').insert({ 
                content, 
                user_id: currentUser.id, 
                post_id: activePostForComment.id, 
                parent_comment_id: parentCommentId,
                reply_to_username: replyToUsername,
                mentioned_users: mentionedUserIds
            }).select('*, post:posts(user_id)').single();

            if (error) {
                console.error('Error submitting comment:', error.message || JSON.stringify(error, null, 2));
                if (postElementOnTimeline) {
                    const countSpan = postElementOnTimeline.querySelector('.comment-count');
                    countSpan.textContent = parseInt(countSpan.textContent) - 1;
                }
            } else {
                const postOwnerId = newComment.post.user_id;
                if (postOwnerId !== currentUser.id) {
                    await db.from('notifications').insert({ recipient_id: postOwnerId, actor_id: currentUser.id, notification_type: 'comment', post_id: activePostForComment.id });
                }
                 if (mentionedUserIds.length > 0) {
                    const notifications = mentionedUserIds.map(userId => ({
                        recipient_id: userId,
                        actor_id: currentUser.id,
                        notification_type: 'mention_comment',
                        post_id: activePostForComment.id
                    }));
                    await db.from('notifications').insert(notifications);
                }
                commentInput.value = '';
                activeReplyTo = null; 
                replyingToBanner.classList.add('hidden');
                await openCommentModal(activePostForComment.id);
            }
            submitCommentButton.disabled = false;
        });

        closeModalButton.addEventListener('click', () => {
            const videoInModal = modalContent.querySelector('video');
            if (videoInModal) {
                videoInModal.pause();
                videoInModal.src = ''; 
            }

            commentModal.classList.remove('is-visible');
            setTimeout(() => {
                commentModal.classList.add('hidden');
                commentModal.classList.remove('flex');
                modalContent.innerHTML = ''; 
                activePostForComment = null;
                activeReplyTo = null;
                replyingToBanner.classList.add('hidden');
                setupVideoAutoplay();
            }, 250);
        });

        function resetComposerStyle() { isFullTextMode = false; fullTextColor = ''; fullTextFont = ''; postContentInput.className = 'w-full p-2 text-lg border-none focus:ring-0 resize-none transition-all duration-300'; postContentInput.style.color = 'black'; postContentInput.rows = 3; }
        function updateComposerFullTextStyle() { postImageFile = null; postVideoFile = null; imageUploadInput.value = ''; videoUploadInput.value = ''; mediaPreviewContainer.innerHTML = ''; postContentInput.className = `w-full p-8 text-lg border-none focus:ring-0 resize-none rounded-lg text-center flex items-center justify-center text-white transition-all duration-300 ${fullTextColor} ${fullTextFont}`; postContentInput.style.color = 'white'; postContentInput.rows = 5; submitPostButton.disabled = !postContentInput.value.trim(); }
        document.getElementById('logout-button').addEventListener('click', async () => { await db.auth.signOut(); window.location.href = 'auth.html'; });
        
        initialize();
    </script>
</body>
</html>

